#!/usr/bin/awk -f

#-
#Copyright...

function usage() {
	print "usage: bhnd_nvram_map.awk <input map>"
	exit 1
}

function warn(msg) {
	print "warning:", msg, "at", mfile, "line", NR > "/dev/stderr"
}

function error(msg) {
	print "error:", msg, "at", mfile, "line", NR ":\n\t" $0 \
	    > "/dev/stderr"
	exit 1
}

# Advance to the next non-comment input record
function next_line() {
	do {
		ret = getline
	} while (ret > 0 && $0 ~ /^[ \t]*#.*/) # skip comment lines
	return ret
}

# Advance to the next input record and verify that it matches @p regex
function getline_matching(regex) {
	ret = next_line()
	if (ret <= 0)
		return ret

	if ($0 ~ regex)
		return 1

	return -1
}

# Find opening brace and adjust block depth
function find_block_open(check_first) {
	if (check_first == "{") {
		BLOCK_START = NR
		depth++
		return
	}

	if (getline_matching("^[ \t]*{") > 0) {
		depth++
		BLOCK_START = NR
		sub("{", "", $0)
		return
	}

	error("found '"$1 "' instead of expected '{'")
}

# Find closing brace and adjust block depth
function find_block_close(check_first) {
	if (check_first == "}") {
		depth--
		return
	}

	if (getline_matching("^[ \t]*}") > 0) {
		depth--
		sub("}", "", $0)
		return
	}

	error("expected '}' (closing block opened on line " BLOCK_START ")")
}

BEGIN {
	if (ARGC != 2)
		usage()

	mfile = ARGV[1]
	depth = 0
}

NR == 1 {
	print "/*"
	print " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT."
	print " *"
	print " * generated from", mfile
	print " */"
}

# Ignore comments
/^[ \t]*#.*/ {
	next
}

# Ensure that operators/punctuators are correctly detected as fields
# by inserting OFS as appropriate
/[^ \t]{/ { gsub(/{/, OFS"{", $0) }	# {
/{[^ \t]/ { gsub(/{/, "{"OFS, $0) }
/[^ \t]}/ { gsub(/{/, OFS"}", $0) }	# }
/}[^ \t]/ { gsub(/{/, "}"OFS, $0) }

# Block definition
$1 == "block[]" {
	find_block_open($2)
	find_block_close($1)
	next
}

# Detect private variable definitions
$1 == "private" {
	sub("private"RS, "", $0)
	private = 1
}

# Variable definition
$1 ~ "(uint|sint|leddc|ccode|mac48)" {
	type = $1
	name = $2

	# Check for and remove array[] specifier
	if (name ~ /\[\]$/) {
		sub(/\[\]$/, "", name);
		array = 1
	}

	print type,name,array
#	//printf("%s %s %s\n", type, name, array)

	next
}

$1 {
	error("unknown type '" $1 "'")
}

{
	error("unrecognized statement")
}