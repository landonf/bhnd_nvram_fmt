#!/usr/bin/awk -f

#-
#Copyright...


BEGIN {
	if (ARGC != 2)
		usage()

	depth = 0
	symbols[depth,"_file"] = FILENAME

	# Common Regexs
	TYPES_REGEX = "(uint|sint|leddc|ccode|mac48)"
	IDENT_REGEX = "[A-Za-z][A-Za-z0-9]*"

	# Internal variable names
	BLOCK_TYPE = "_block_type"
	BLOCK_NAME = "_block_name"
	BLOCK_START = "_block_start"
}

NR == 1 {
	print "/*"
	print " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT."
	print " *"
	print " * generated from", FILENAME
	print " */"
}

# Save the unmodified source line
{
	SRCLINE = $0
}

function usage ()
{
	print "usage: bhnd_nvram_map.awk <input map>"
	exit 1
}

# Print a warning to stderr
function warn (msg)
{
	print "warning:", msg, "at", FILENAME, "line", NR > "/dev/stderr"
}

# Print a compiler error to stderr
function error (msg)
{
	print "error:", msg, "at", FILENAME, "line", NR ":\n\t" SRCLINE \
	   > "/dev/stderr"
	exit 1
}

# Advance to the next non-comment input record
function next_line ()
{
	do {
		_result = getline
		SRCLINE = $0
	} while (_result > 0 && $0 ~ /^[ \t]*#.*/) # skip comment lines
	return _result
}

# Advance to the next input record and verify that it matches @p regex
function getline_matching (regex)
{
	_result = next_line()
	if (_result <= 0)
		return _result

	if ($0 ~ regex)
		return 1

	return -1
}

# Find opening brace and adjust block depth
# If optional is true and no open brace is found, 0 is returned. Otherwise, 1.
function open_block (type, name, check_first, optional)
{
	if (check_first == "{" || getline_matching("^[ \t]*{") > 0) {
		depth++
		push(BLOCK_START, NR)
		push(BLOCK_NAME, name)
		push(BLOCK_TYPE, type)
		return 1
	}

	if (optional)
		return 0

	error("found '"$1 "' instead of expected '{' for '" name "'")
}

# Find closing brace and adjust block depth
function close_block (check_first)
{
	# drop all symbols defined at this depth
	block_start = lookup(BLOCK_START)
	for (s in symbols) {
		if (s ~ "^"depth"[^0-9]")
			delete symbols[s]
	}

	if (check_first == "}") {
		depth--
		return
	}

	if (getline_matching("^[ \t]*}") > 0) {
		depth--
		return
	}

	error("expected '}' (block opened on line " block_start ")")
}

# Look up a variable with `name` (and optional default value if not found)
# in the current symbol table. If deflt is not specified and the
# variable is not defined, a compiler error will be emitted.
function lookup (name, deflt)
{
	for (i = 0; i < depth; i++) {
		if ((depth-i,name) in symbols)
			return symbols[depth-i,name]
	}

	if (deflt)
		return deflt
	else
		error("'" name "' is undefined")
}

# Define a new variable in the symbol table's current scope,
# with the given value
function push (name, value)
{
	symbols[depth,name] = value
}

# Set an existing variable's value in the symbol table; if not yet defined,
# a new variable will be defined within the current scope.
function set (name, value)
{
	for (i = 0; i < depth; i++) {
		if ((depth-i,name) in symbols) {
			symbols[depth-i,name] = value
			return
		}
	}

	# No existing value
	push(name, value)
}

# Evaluates to true if immediately within a block scope of the given type
function in_block (type)
{
	return (type == lookup(BLOCK_TYPE, "NONE"))
}

# Evaluates to true if within an immediate or non-immediate block scope of the
# given type
function in_nested_block (type)
{
	for (i = 0; i < depth; i++) {
		if ((depth-i,BLOCK_TYPE) in symbols) {
			if (symbols[depth-i,BLOCK_TYPE] == type)
				return 1
		}
	}
	return 0
}

# Evaluates to true if definitions of the given type are permitted within
# the current scope
function allow_def (type)
{
	if (type == "var" || type == "sprom") {
		return (in_block("NONE") || in_block("struct") ||
		    in_block("var"))
	} else if (type == "struct") {
		return (in_block("NONE"))
	} else if (type == "revs") {
		return (in_block("sprom"))
	}

	error("unknown type '" type "'")
}

# Ignore comments
/^[ \t]*#.*/ {
	next
}

# Ignore blank lines
/^[ \t]*$/ {
	next
}

# Parser limitations require that open/close blocks stand alone
(/{/ && /{[ \t]*[^ \t]/) {
	error("'{' must be the last character on a line")
}
(/}/ && /[ \t]*}[ \t*][^ \t]/) {
	error("'}' must be the only non-whitespace character on a line")
}

# Ensure that operators/punctuators are correctly detected as fields
# by inserting OFS as appropriate
/[^ \t]{/ { gsub(/{/, OFS"{", $0) }	# {
/{[^ \t]/ { gsub(/{/, "{"OFS, $0) }
/[^ \t]}/ { gsub(/{/, OFS"}", $0) }	# }
/}[^ \t]/ { gsub(/{/, "}"OFS, $0) }

# struct definition
$1 == "struct" && allow_def("struct") {
	# Remove array[] specifier
	if (sub(/\[\]$/, "", $2) == 0)
		error("expected '" $2 "[]', not '" $2 "'")

	open_block($1, $2, $3)
	print "STRUCT",lookup(BLOCK_NAME)
	next
}

$1 == "}" && in_block("struct") {
	# TODO: Define struct
	close_block($1)
	next
}

# sprom block
$1 == "sprom" && allow_def("sprom") {
	open_block($1, "", $2)
	print "SPROM {}"
	next
}

$1 == "}" && in_block("sprom") {
	# TODO: Define SPROM
	close_block($1)
	next
}

# revs block
$1 == "revs" && allow_def("revs") {
	if ($2 ~ "[0-9]*-[0-9*]") {
		_block = open_block($1, "", $3, 1)
	} else if ($2 ~ "(>|>=|<|<=)" && $3 ~ "[1-9][0-9]*") {
		print "range",$2,$3
		_block = open_block($1, "", $4, 1)
	} else if ($2 ~ "[1-9][0-9]*") {
		print "equality",$2
		_block = open_block($1, "", $3, 1)
	} else {
		error("invalid rev designator")
	}

	# Single line behavior
	if (!_block) {
		print "do single line match on",$1,$2,$3,$4
	}

	next
}

# offset definition
$1 ~ IDENT_REGEX && in_block("revs") {
	print "offset="$1
	next
}

$1 == "}" && in_block("revs") {
	# TODO: Define REV
	close_block($1)
	next
}

# Detect private variable flag
$1 == "private" && $2 ~ TYPES_REGEX && allow_def("var") {
	sub("^private"FS, "", $0)
	_private = 1
}

# Variable definition
$1 ~ TYPES_REGEX && allow_def("var") {
	type = $1
	name = $2
	open_block("var", name, $3)

	# Check for and remove array[] specifier
	if (sub(/\[\]$/, "", name) > 0)
		array = 1

	print type,name,array
#	//printf("%s %s %s\n", type, name, array)

	next
}

# Variable parameters
$1 ~ IDENT_REGEX && $2 ~ IDENT_REGEX && in_block("var") {
	if ($1 == "sfmt")
		print $1"="$2
	next
}

$1 == "}" && in_block("var") {
	# TODO: Define var
	close_block($1)
	next
}

$1 == "}" {
	error("unbalanced '}'")
}

$1 && allow_def("var") {
	error("unknown type '" $1 "'")
}

{
	error("unrecognized statement")
}