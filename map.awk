#!/usr/bin/awk -f

#-
#Copyright...

BEGIN {
	if (ARGC != 2)
		usage()

	depth = 0
	symbols[depth,"_file"] = FILENAME
}

NR == 1 {
	print "/*"
	print " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT."
	print " *"
	print " * generated from", FILENAME
	print " */"
}

function lookup(name) {
	for (i = 0; i < depth; i++) {
		if ((depth-i,name) in symbols)
			return symbols[depth-i,name]
	}

	error("'" name "' is undefined")
}

function push(name, value) {
	symbols[depth,name] = value
}

function set(name, value) {
	for (i = 0; i < depth; i++) {
		if ((depth-i,name) in symbols) {
			symbols[depth-i,name] = value
			return
		}
	}

	# No existing value
	push(name, value)
}

function usage() {
	print "usage: bhnd_nvram_map.awk <input map>"
	exit 1
}

function warn(msg) {
	print "warning:", msg, "at", FILENAME, "line", NR > "/dev/stderr"
}

function error(msg) {
	print "error:", msg, "at", FILENAME, "line", NR ":\n\t" $0 \
	    > "/dev/stderr"
	exit 1
}

# Advance to the next non-comment input record
function next_line() {
	do {
		ret = getline
	} while (ret > 0 && $0 ~ /^[ \t]*#.*/) # skip comment lines
	return ret
}

# Advance to the next input record and verify that it matches @p regex
function getline_matching(regex) {
	ret = next_line()
	if (ret <= 0)
		return ret

	if ($0 ~ regex)
		return 1

	return -1
}

# Find opening brace and adjust block depth
function find_block_open(check_first) {
	if (check_first == "{") {
		depth++
		push("_block_start", NR)
		return
	}

	if (getline_matching("^[ \t]*{") > 0) {
		depth++
		push("_block_start", NR)
		sub("{", "", $0)
		return
	}

	error("found '"$1 "' instead of expected '{'")
}

# Find closing brace and adjust block depth
function find_block_close(check_first) {
	# drop all symbols defined at this depth
	block_start = lookup("_block_start")
	for (s in symbols) {
		if (s ~ "^"depth"[^0-9]")
			delete symbols[s]
	}

	if (check_first == "}") {
		depth--
		return
	}

	if (getline_matching("^[ \t]*}") > 0) {
		depth--
		sub("}", "", $0)
		return
	}

	error("expected '}' (block opened on line " block_start ")")
}


# Ignore comments
/^[ \t]*#.*/ {
	next
}

# Ignore blank lines
/^[ \t]*$/ {
	next
}

# Ensure that operators/punctuators are correctly detected as fields
# by inserting OFS as appropriate
/[^ \t]{/ { gsub(/{/, OFS"{", $0) }	# {
/{[^ \t]/ { gsub(/{/, "{"OFS, $0) }
/[^ \t]}/ { gsub(/{/, OFS"}", $0) }	# }
/}[^ \t]/ { gsub(/{/, "}"OFS, $0) }

# Block definition
$1 == "block[]" {
	find_block_open($2)
	if (getline_matching("^[ \t]*sprom[ \t]") <= 0) {
		error("expected 'sprom' definitions")
	} else {
		find_block_open($2)

		while (getline_matching("^[ \t]*revs[ \t]") > 0) {
			while (getline_matching("^[ \t]*@") > 0) {

			}
		}

		find_block_close($1)
	}



	find_block_close($1)
	next
}

# Detect private variable definitions
$1 == "private" {
	sub("private"RS, "", $0)
	private = 1
}

# Variable definition
$1 ~ "(uint|sint|leddc|ccode|mac48)" {
	type = $1
	name = $2

	# Check for and remove array[] specifier
	if (sub(/\[\]$/, "", name) > 0)
		array = 1

	print type,name,array
#	//printf("%s %s %s\n", type, name, array)

	next
}

$1 {
	error("unknown type '" $1 "'")
}

{
	error("unrecognized statement")
}