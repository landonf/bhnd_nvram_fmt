#!/usr/bin/awk -f

#-
#Copyright...


BEGIN {
	if (ARGC != 2)
		usage()

	RS="\n"

	depth = 0
	symbols[depth,"_file"] = FILENAME

	# Enable debug output
	DEBUG = 1

	# Maximum revision
	REV_MAX = 65535

	# Format Constants
	FMT["hex"]	= "BHND_NVRAM_VFMT_HEX"
	FMT["sdec"]	= "BHND_NVRAM_VFMT_SDEC"
	FMT["ccode"]	= "BHND_NVRAM_VFMT_CCODE"
	FMT["macaddr"]	= "BHND_NVRAM_VFMT_MACADDR"
	FMT["led_dc"]	= "BHND_NVRAM_VFMT_LEDDC"

	# Data Type Constants
	DTYPE["uint"]	= "BHND_NVRAM_DT_UINT"
	DTYPE["int"]	= "BHND_NVRAM_DT_SINT"
	DTYPE["char"]	= "BHND_NVRAM_DT_CHAR"

	# Default masking for standard widths
	WMASK["u8"]	= "0x000000FF"
	WMASK["u16"]	= "0x0000FFFF"
	WMASK["u32"]	= "0xFFFFFFFF"

	# Byte sizes for standard widths
	WBYTES["u8"]	= "1"
	WBYTES["u16"]	= "2"
	WBYTES["u32"]	= "4"

	# Common Regexs
	INT_REGEX	= "[1-9][0-9]*"
	HEX_REGEX	= "0x[A-Fa-f0-9]+"
	TYPES_REGEX	= "(u?int(8|16|32)|char)(\\[" INT_REGEX "\\])?"
	IDENT_REGEX	= "[A-Za-z_][A-Za-z0-9_]*"

	# Internal variable names
	BLOCK_TYPE	= "_block_type"
	BLOCK_NAME	= "_block_name"
	BLOCK_START	= "_block_start"

	# Common array keys
	DEF_LINE	= "def_line"
	NUM_REVS	= "num_revs"
	REV		= "rev"

	# Revision array keys
	REV_START	= "rev_start"
	REV_END		= "rev_end"
	REV_DESC	= "rev_decl"
	REV_NUM_OFFS	= "num_offs"

	# Offset array keys
	OFF 		= "off"
	OFF_NUM_SEGS	= "off_num_segs"
	OFF_SEG		= "off_seg"

	# Segment array keys
	SEG_ADDR	= "seg_addr"
	SEG_WIDTH	= "seg_width"
	SEG_COUNT	= "seg_count"
	SEG_MASK	= "seg_mask"
	SEG_SHIFT	= "seg_shift"

	# Variable array keys
	VAR_NAME	= "v_name"
	VAR_TYPE	= "v_type"
	VAR_FMT		= "v_fmt"
	VAR_STRUCT	= "v_parent_struct"
	VAR_PRIVATE	= "v_private"
	VAR_ARRAY	= "v_array"
	VAR_IGNALL1	= "v_ignall1"
}

NR == 1 {
	print "/*"
	print " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT."
	print " *"
	print " * generated from", FILENAME
	print " */"
	print ""
	print "#include \"ccmach/nvram_map.h\""
}

# print msg, indented for the current output depth
function printi (msg)
{
	for (_ind = 0; _ind < output_depth; _ind++)
		printf("\t")

	if (msg != null)
		printf("%s", msg)
}

function gen_var_flags (v)
{
	_flags = "BHND_NVRAM_VF_DFLT"
	if (vars[v,VAR_ARRAY])
		_flags = _flags "|BHND_NVRAM_VF_ARRAY"

	if (vars[v,VAR_PRIVATE])
		_flags = _flags "|BHND_NVRAM_VF_MFGINT"

	if (vars[v,VAR_IGNALL1])
		_flags = _flags "|BHND_NVRAM_VF_IGNALL1"

	# TODO BHND_NVRAM_VF_IGNALL1
	return _flags
}

function gen_var_head (v, suffix)
{
	printi("{\"" v suffix "\", ")
	printf("%s, ", DTYPE[vars[v,VAR_TYPE]])
	printf("%s, ", FMT[vars[v,VAR_FMT]])
	printf("%s, ", gen_var_flags(v))
	printf("(struct bhnd_sprom_var[]) {\n")
	output_depth++
}

function gen_var_rev_body (revk, base_addr)
{
	if (base_addr != null)
		base_addr = base_addr"+"
	else
		base_addr = ""

	printi()
	printf("{{%u, %u}, (struct bhnd_sprom_offset[]) {\n",
	    vars[revk,REV_START],
	    vars[revk,REV_END])
	output_depth++

	num_offs = vars[revk,REV_NUM_OFFS]
	num_offs_written = 0
	for (offset = 0; offset < num_offs; offset++) {
		offk = subkey(revk, OFF, offset"")
		num_segs = vars[offk,OFF_NUM_SEGS]

		for (seg = 0; seg < num_segs; seg++) {
			segk = subkey(offk, OFF_SEG, seg"")

			printi()
			printf("{%s, %s, %s, %s, %s, %s},\n",
			    base_addr vars[segk,SEG_ADDR],
			    vars[segk,SEG_WIDTH],
			    vars[segk,SEG_COUNT],
			    vars[segk,SEG_MASK],
			    vars[segk,SEG_SHIFT],
			    (num_segs-1 > seg) ? "true" : "false")
			num_offs_written++
		}
	}
	output_depth--
	printi("}, " num_offs_written "},\n")
}

function gen_var_body (v, base_addr)
{
	for (rev = 0; rev < vars[v,NUM_REVS]; rev++) {
		revk = subkey(v, REV, rev"")
		gen_var_rev_body(revk)
	}
}

function gen_var_tail (v, num_revs)
{
	output_depth--
	printi("}, " num_revs "},\n")
}

function gen_struct_var (v)
{
	st = vars[v,VAR_STRUCT]
	st_max_off = 0

	# determine the total number of variables to generate
	for (srev = 0; srev < structs[st,NUM_REVS]; srev++) {
		srevk = subkey(st, REV, srev"")
		for (off = 0; off < structs[srevk,REV_NUM_OFFS]; off++) {
			if (off > st_max_off)
				st_max_off = off
		}
	}

	# generate variables for each defined struct offset
	for (off = 0; off < st_max_off; off++) {
		st_rev_count = 0
		gen_var_head(v, off"")

		for (srev = 0; srev < structs[st,NUM_REVS]; srev++) {
			srevk = subkey(st, REV, srev"")

			# Skip offsets not defined for this revision
			if (off > structs[srevk,REV_NUM_OFFS])
				continue

			offk = subkey(srevk, OFF, off"")
			base_addr = structs[offk,SEG_ADDR]

			for (vrev = 0; vrev < vars[v,NUM_REVS]; vrev++) {
				vrevk = subkey(v, REV, vrev"")
				v_start = vars[vrevk,REV_START]
				v_end = vars[vrevk,REV_END]
				s_start = structs[srevk,REV_START]
				s_end = structs[srevk,REV_END]

				# XXX we don't support computing the union
				# of partially overlapping ranges
				if ((v_start < s_start && v_end >= s_start) ||
				    (v_start <= s_end && v_end > s_end))
				{
					errorx("partially overlapping " \
					    "revision ranges are not supported")
				}

				# skip variables revs that are not within
				# the struct offset's compatibility range
				if (v_start < s_start || v_start > s_end ||
				    v_end < s_start || v_end > s_end)
					continue

				st_rev_count++
				gen_var_rev_body(vrevk, base_addr)
			}
		}

		gen_var_tail(v, st_rev_count)
	}
}

END {


	# skip completion handling if exiting from an error
	if (_EARLY_EXIT)
		exit 1

	# check for complete block closure
	if (depth > 0) {
		block_start = g(BLOCK_START)
		errorx("missing '}' for block opened on line " block_start "")
	}

	# generate output
	printf("const struct bhnd_nvram_var nvram_vars[] = {\n")
	output_depth = 1
	for (v in var_names) {
		if (vars[v,VAR_STRUCT] != null) {
			gen_struct_var(v)
		} else {
			gen_var_head(v)
			gen_var_body(v)
			gen_var_tail(v, vars[v,NUM_REVS])
		}
	}
	output_depth = 0
	printf("};\n")
}

function usage ()
{
	print "usage: bhnd_nvram_map.awk <input map>"
	exit 1
}

# Print a warning to stderr
function warn (msg)
{
	print "warning:", msg, "at", FILENAME, "line", NR > "/dev/stderr"
}

# Print a compiler error to stderr
function error (msg)
{
	errorx(msg " at " FILENAME " line " NR ":\n\t" $0)
}

# Print an error message without including the source line information
function errorx (msg)
{
	print "error:", msg > "/dev/stderr"
	_EARLY_EXIT=1
	exit 1
}

# Print a debug output message
function debug (msg)
{
	if (!DEBUG)
		return
	for (_di = 0; _di < depth; _di++)
		printf("\t") > "/dev/stderr"
	print msg > "/dev/stderr"
}

# Return an array key composed of the given (parent, selector, child)
# tuple. the child argument is optional and may be omitted.
function subkey (parent, selector, child)
{
	if (child != null)
		return parent SUBSEP selector SUBSEP child
	else
		return parent SUBSEP selector
}

# Advance to the next non-comment input record
function next_line ()
{
	do {
		_result = getline
	} while (_result > 0 && $0 ~ /^[ \t]*#.*/) # skip comment lines
	return _result
}

# Advance to the next input record and verify that it matches @p regex
function getline_matching (regex)
{
	_result = next_line()
	if (_result <= 0)
		return _result

	if ($0 ~ regex)
		return 1

	return -1
}

# Shift the current fields left by `n`. If all fields are consumed and
# the optional do_getline argument is true, read the next line.
function shiftf (n, do_getline)
{
	if (n > NF) error("shift past end of line")
	for (_si = 1; _si <= NF-n; _si++) {
		$(_si) = $(_si+n)
	}
	NF = NF - n

	if (NF == 0 && do_getline)
		next_line()
}

# Parse a revision descriptor from the current line
function parse_revdesc (result)
{
	_rstart = 0
	_rend = 0

	if ($2 ~ "[0-9]*-[0-9*]") {
		split($2, _revrange, "[ \t]*-[ \t]*")
		_rstart = _revrange[1]
		_rend = _revrange[2]
	} else if ($2 ~ "(>|>=|<|<=)" && $3 ~ "[1-9][0-9]*") {
		if ($2 == ">") {
			_rstart = int($3)+1
			_rend = REV_MAX
		} else if ($2 == ">=") {
			_rstart = int($3)
			_rend = REV_MAX
		} else if ($2 == "<" && int($3) > 0) {
			_rstart = 0
			_rend = int($3)-1
		} else if ($2 == "<=") {
			_rstart = 0
			_rend = int($3)-1
		} else {
			error("invalid revision descriptor")
		}
	} else if ($2 ~ "[1-9][0-9]*") {
		_rstart = int($2)
		_rend = int($2)
	} else {
		error("invalid revision descriptor")
	}

	result[REV_START] = _rstart
	result[REV_END] = _rend
}

# Find opening brace and adjust block depth. The name may be null, in which
# case the BLOCK_NAME variable will not be defined in this scope
function open_block (type, name)
{
	if ($0 ~ "{" || getline_matching("^[ \t]*{") > 0) {
		depth++
		push(BLOCK_START, NR)
		if (name != null)
			push(BLOCK_NAME, name)
		push(BLOCK_TYPE, type)

		sub("^[^{]+{", "", $0)
		return 1
	}

	error("found '"$1 "' instead of expected '{' for '" name "'")
}

# Find closing brace and adjust block depth
function close_block ()
{
	if ($0 !~ "}")
		error("internal error - no closing brace")

	# drop all symbols defined at this depth
	for (s in symbols) {
		if (s ~ "^"depth"[^0-9]")
			delete symbols[s]
	}

	# strip everything prior to the block closure
	sub("^[^}]*}", "", $0)
	depth--
}

# Look up a variable in the symbol table with `name`, optional default value if
# not found, and an optional scope level to start searching.
#
# If deflt is null and the variable is not defined, a compiler error will be
# emitted.
# The scope level is defined relative to the current scope -- 0 is the current
# scope, 1 is the parent scope, etc.
function g (name, deflt, scope)
{
	if (scope == null)
		scope = 0;

	for (i = scope; i < depth; i++) {
		if ((depth-i,name) in symbols)
			return symbols[depth-i,name]
	}

	if (deflt)
		return deflt
	else
		error("'" name "' is undefined")
}

# Define a new variable in the symbol table's current scope,
# with the given value
function push (name, value)
{
	symbols[depth,name] = value
}

# Set an existing variable's value in the symbol table; if not yet defined,
# will trigger an error
function set (name, value, scope)
{
	for (i = 0; i < depth; i++) {
		if ((depth-i,name) in symbols) {
			symbols[depth-i,name] = value
			return
		}
	}
	# No existing value, cannot define
	error("'" name "' is undefined")
}

# Evaluates to true if immediately within a block scope of the given type
function in_block (type)
{
	return (type == g(BLOCK_TYPE, "NONE"))
}

# Evaluates to true if within an immediate or non-immediate block scope of the
# given type
function in_nested_block (type)
{
	for (i = 0; i < depth; i++) {
		if ((depth-i,BLOCK_TYPE) in symbols) {
			if (symbols[depth-i,BLOCK_TYPE] == type)
				return 1
		}
	}
	return 0
}

# Evaluates to true if definitions of the given type are permitted within
# the current scope
function allow_def (type)
{
	if (type == "var") {
		return (in_block("NONE") || in_block("struct"))
	} else if (type == "struct") {
		return (in_block("NONE"))
	} else if (type == "srom") {
		return (in_block("var"))
	} else if (type == "struct_srom") {
		return (in_block("struct"))
	}

	error("unknown type '" type "'")
}

# struct definition
$1 == "struct" && allow_def("struct") {
	name = $2

	# Remove array[] specifier
	if (sub(/\[\]$/, "", name) == 0)
		error("expected '" name "[]', not '" name "'")

	if (name !~ "^"IDENT_REGEX"$" || name ~ "^"TYPES_REGEX"$")
		error("invalid identifier '" name "'")

	# Add top-level struct entry 
	if ((name,DEF_LINE) in structs) 
		error("struct identifier '" name "' previously defined on " \
		    "line " structs[name,DEF_LINE])
	structs[name,DEF_LINE] = NR
	structs[name,NUM_REVS] = 0

	# Open the block 
	debug("struct " name " {")
	open_block($1, name)
}

# struct rev descriptor
$1 == "srom" && allow_def("struct_srom") {
	sid = g(BLOCK_NAME)

	# parse revision descriptor
	rev_desc[REV_START] = 0
	parse_revdesc(rev_desc)

	# assign revision id
	rev = structs[sid,NUM_REVS] ""
	revk = subkey(sid, REV, rev)
	structs[sid,NUM_REVS]++

	# init basic revision state
	structs[revk,REV_START] = rev_desc[REV_START]
	structs[revk,REV_END] = rev_desc[REV_END]

	if (match($0, "\\[[^]]*\\]") <= 0)
		error("expected base address array")

	addrs_str = substr($0, RSTART+1, RLENGTH-2)
	num_offs = split(addrs_str, addrs, ",[ \t]*")
	structs[revk, REV_NUM_OFFS] = num_offs
	for (i = 1; i <= num_offs; i++) {
		offk = subkey(revk, OFF, (i-1) "")

		if (addrs[i] !~ "^"HEX_REGEX"$")
			error("invalid base address '" addrs[i] "'")

		structs[offk,SEG_ADDR] = addrs[i]
	}

	debug("struct_srom " structs[revk,REV_START] "... [" addrs_str "]")
	next
}

# variable srom revs block
$1 == "srom" && allow_def("srom") {
	# parse revision descriptor
	parse_revdesc(rev_desc)

	# assign revision id
	vid = g(BLOCK_NAME)
	rev = vars[vid,NUM_REVS] ""
	revk = subkey(vid, REV, rev)
	vars[vid,NUM_REVS]++

	# vend scoped rev/revk variables for use in the
	# revision offset block
	push("rev_id", rev)
	push("rev_key", revk)

	# init basic revision state
	vars[revk,REV_START] = rev_desc[REV_START]
	vars[revk,REV_END] = rev_desc[REV_END]
	vars[revk,REV_NUM_OFFS] = 0

	debug("srom " _revstr " {")
	open_block($1, null)
}

function parse_offset_segment (revk, offk)
{
	vid = g(BLOCK_NAME)

	# assign segment id
	seg = vars[offk,OFF_NUM_SEGS] ""
	segk = subkey(offk, OFF_SEG, seg)
	vars[offk,OFF_NUM_SEGS]++

	type=$1
	offset=$2

	if (type !~ "^"WIDTHS_REGEX"$")
		error("unknown field width '" $1 "'")

	if (offset !~ "^"HEX_REGEX",?$")
		error("invalid offset value '" $2 "'")

	# clean up any trailing comma on the offset field
	sub(",$", "", offset)

	# extract byte count[] and width
	if (match(type, "\\["INT_REGEX"\\]$") > 0) {
		count = substr(type, RSTART+1, RLENGTH-2)
		type = substr(type, 1, RSTART-1)
	} else {
		count = 1
	}
	width = WBYTES[type]

	# seek to attributes or end of the offset expr
	sub("^[^,(|){}]+", "", $0)


	# parse attributes
	mask=WMASK[type]
	shift=0

	if ($1 ~ "^\\(") {
		# extract attribute list
		if (match($0, "\\([^|\(\)]*\\)") <= 0)
			error("expected attribute list")
		attr_str = substr($0, RSTART+1, RLENGTH-2)

		# drop from input line
		$0 = substr($0, RSTART+RLENGTH, length($0) - RSTART+RLENGTH)

		# parse attributes
		num_attr = split(attr_str, attrs, ",[ \t]*")
		for (i = 1; i <= num_attr; i++) {
			attr = attrs[i]
			if (sub("^&[ \t]*", "", attr) > 0) {
				mask = attr
			} else if (sub("^<<[ \t]*", "", attr) > 0) {
				shift = "-"attr
			} else if (sub("^>>[ \t]*", "", attr) > 0) {
				shift = attr
			} else {
				error("unknown attribute '" attr "'")
			}
		}
	}

	vars[segk,SEG_ADDR]	= offset
	vars[segk,SEG_WIDTH]	= width
	vars[segk,SEG_COUNT]	= count
	vars[segk,SEG_MASK]	= mask
	vars[segk,SEG_SHIFT]	= shift
	debug("{"offset", " width ", " mask ", " shift"}" _comma)
}

# revision offset definition
($1 ~ "^"TYPES_REGEX"$" || $1 "^"HEX_REGEX"$") && in_block("srom") {
	vid = g(BLOCK_NAME)

	# fetch rev id/key defined by our parent block
	rev = g("rev_id")
	revk = g("rev_key")

	# parse all offsets
	do {
		# assign offset id
		off = vars[revk,REV_NUM_OFFS] ""
		offk = subkey(revk, OFF, off)
		vars[revk,REV_NUM_OFFS]++

		# initialize segment count
		vars[offk,OFF_NUM_SEGS] = 0

		debug("[")
		# parse all segments
		do {
			parse_offset_segment(revk, offk)
			_more_seg = ($1 == "|")
			if (_more_seg)
				shiftf(1, 1)
		} while (_more_seg)
		debug("],")
		_more_vals = ($1 == ",")
		if (_more_vals)
			shiftf(1, 1)
	} while (_more_vals)
}

# variable definition
(($1 == "private" && $2 ~ "^"TYPES_REGEX"$") || $1 ~ "^"TYPES_REGEX"$") && \
    allow_def("var") \
{
	# check for 'private' flag
	if ($1 == "private") {
		private = 1
		shiftf(1)
	} else {
		private = 0
	}

	type = $1
	name = $2
	array = 0
	debug(type " " name " {")

	# Check for and parse any array[] specifier
	if (match(type, "\\["INT_REGEX"\\]$") > 0) {
		count = substr(type, RSTART+1, RLENGTH-2)
		type = substr(type, 1, RSTART-1)
		array = 1
	} else {
		count = 1
	}

	# verify type
	if (!type in DTYPE)
		error("unknown type '" $1 "'")

	# Add top-level variable entry 
	if (name in var_names) 
		error("variable identifier '" name "' previously defined on " \
		    "line " vars[name,DEF_LINE])

	var_names[name] = 0
	vars[name,DEF_LINE] = NR
	vars[name,VAR_TYPE] = type
	vars[name,NUM_REVS] = 0
	vars[name,VAR_PRIVATE] = private
	vars[name,VAR_ARRAY] = array
	vars[name,VAR_FMT] = "hex" # default if not specified

	open_block("var", name)

	# Mark as a struct-based variable
	if (in_nested_block("struct")) {
		sid = g(BLOCK_NAME, null, 1)
		vars[name,VAR_STRUCT] = sid
	}

	debug("type=" DTYPE[type])
}

# variable parameters
$1 ~ "^"IDENT_REGEX"$" && $2 ~ "^"IDENT_REGEX";?$" && in_block("var") {
	vid = g(BLOCK_NAME)
	if ($1 == "fmt") {
		if (!$2 in FMT)
			error("invalid fmt '" $2 "'")

		vars[vid,VAR_FMT] = $2
		debug($1 "=" FMT[$2])
	} else if ($1 == "all1" && $2 == "ignore") {
		vars[vid,VAR_IGNALL1] = 1
	} else {
		error("unknown parameter " $1)
	}
	next
}

# Skip comments and blank lines
/^[ \t]*#/ || /^$/ {
	next
}

# Close blocks
/}/ && !in_block("NONE") {
	while (!in_block("NONE") && $0 ~ "}") {
		close_block();
		debug("}")
	}
	next
}

# Report unbalanced '}'
/}/ && in_block("NONE") {
	error("extra '}'")
}

# Invalid variable type
$1 && allow_def("var") {
	error("unknown type '" $1 "'")
}

# Generic parse failure
{
	error("unrecognized statement")
}
